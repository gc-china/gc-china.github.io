<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[记录最近面试中笔试和被问到的问题]]></title>
    <url>%2F2019%2F07%2F20%2F%E8%AE%B0%E5%BD%95%E6%9C%80%E8%BF%91%E9%9D%A2%E8%AF%95%E4%B8%AD%E7%AC%94%E8%AF%95%E5%92%8C%E8%A2%AB%E9%97%AE%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[最近在找工作,也记一下面试中和笔试被问到的题,长期更新 JRE和JDK 的区别 JRE 是 java运行环境的意思,包含Java虚拟机和常用Java类库 JDK 是java 开发工具包 JDK 是用于开发 JRE 是用于运行java代码的 JDK=JRE+Java运行工具 JRE=JVM+常用类库 == 和equals 的区别 ==和equals 都是在比较时使用, 在比较基本数据类型的时候 == 比较的是值是否相等在比较引用类型的时候 equals 是一个方法 他只可以比较引用引用类型 在重写的时候比较的是内存地址! 两个对象的hashCode()相同 则equals()一定为true吗? false 因为在一般情况下 equals 比较的是内存地址是一样的 所以HashCode 的值一般是相同的,但是equeals 可以被重写 重写后比较的是值是否相同! final 在Java中修饰的作用 final 表示不可修改的 他可以修改类和属性和方法 当final 修饰类的时候 表示该类不能被继承,该类中的成员方法都会被隐式指定为final 修饰 当final 修饰方法的时候 表示该方法不能被重写 当final 修饰属性的时候 表示该属性不能改变 当变量是基本类型表示该变量不能的值不能修改,如果是引用类型 表示该变量被初始化后不能指向另一个对象 String 是基本数据类型吗? String 不是基本数据类型,String是一个对象 基本类型用八种 逻辑型 Boolean 字符型 char 浮点型 float double 整数型 byte long int short String str=&quot;i&quot;; String str2=new String(&quot;i&quot;); str == str2 false 因为str 是一个常量str2 是个对象 它们的内存地址不一样 String 类中有什么常用的方法 1234561. equals() : 比较字符串是否相同2. length() : 计算字符串长度3. concat() : 拼接字符串4. charAt(int index) : 截取指定位置字符5. substring(int bgindex, int endindex) : 截取指定位置区间的字符 6. HashCode() : 返回字符串的Hash值 抽象类和接口的区别 抽象类是单继承的接口可以多实现 抽象类可以构照,接口是不能有构照器 抽象类一般作为类的共有属性 接口是一般定义共有的方法 List和Set 和Map 有什么区别 List 和Set 是单列集合 Map 是双列集合 List 是有序可重复的 可以插入null Set 是无序不可重复的 也可以插入null 值 HashMap 和Hashtable有什么区别 HashMap 和Hashtable 他们的成员方法都一样 但是Hashtable 是同步的所以是线程安全的 Hashmap 是线程不安全的 所以Hashmap 速率比较快 ArrayList 和LinkList 的区别 ArryList 是底层是动态数组形成的 所以在做查改的操作是速度较快LinkList 是链表形成的 所以在增删操作速度较快 ArrayList 和Vector 的区别 ArrayList 是线程不安全的没有进行同步 Vector 是线程安全所以ArryList 的效率比Vector 高 创建线程有多少种方法 实现runnable 的接口 继承Thread 类 线程的声明周期 线程的初始化(新建) 就绪状态 运行状态 阻塞状态 死亡状态 sellp和wait 的区别 sellp 是Object 的方法 wait 是Thread 的方法 它们都是将线程沉睡 但是sellp 是讲指定睡眠多久时长到时间会自动唤醒 wait方法 是需要notify 或者notifyall 唤醒！而sellp 在进行不会释放锁对象而wait 释放锁对象 线程的Run方法和start 方法的区别 run方法是线程的入口 start 方法是启动线程方法 当直接调用run方法的时候 run就是个普通方法 只要使用start 异步调用run 方法才是开启线程 什么是死锁 死锁是两个以上的进程在访问同个资源的时候由于竞争资源或者在通信出现一种无限阻塞状态 get请求和post 请求的区别 get 的请求是将参数拼接在Url 上post是将参数写在请求头上 所以post的请求相对来说更安全在Rest风格中get 请求是将指定资源请求数据 post是将资源提交给指定资源 讲讲Spring 是啥 Spring 是一个JavaEE轻量级框架 在Spring 中两大特性AOP 和IOC AOP 面向切面编程 IOC 依赖注入 依靠着两个特性能简化我们的开发 Spring 是IOC 和AOP Spring IOC 是依赖注入是将控制权交给Spring管理 将创建对象的时候由Spring 为你们创建对象 为属性赋值等 依赖注入有两种方式一致Setting 和一种 构照器 注入 依赖注入的底层是利用反射实现的 而Aop 面向切面编程是oop面向对象的一种拓展 是将一切都抽象为一个切面 从而可以对进行增强 在Spring中有五中增强前置通知 后置通知 环绕通知 erro 通知 最终通知 Aop 是由动态代理实现的！ SpringBean 支持多少种作用域 Singleton:单例 在整个Springioc容器中 整个Bean将只能有一个实例 Prototype: 原型模式 每次通过GetBean 获取实例的时候 将会产生一个新的Bena实例 request : 对每次Http请求 使用Request 定义的Bean 都会参数一个实例 Session : 对每次HTTP请求 使用Request 定义的bean 都将产生一个新的实例 globalsession：每一个全局的HTTP Session，使用session定义的bean都将产生一个新实例 讲讲SpringMVC 的流程 1）用户发送请求到DispatchServlet 2）DispatchServlet根据请求路径查询具体的Handler 3）HandlerMapping返回一个HandlerExcutionChain给&gt; DispatchServlet4）DispatchServlet调用HandlerAdapter适配器 5）HandlerAdapter调用具体的Handler处理业务6）Handler处理结束返回一个具体的ModelAndView给适配器7）适配器将ModelAndView给DispatchServlet8）DispatchServlet把视图名称给viewResolver视图解析器9）viewREsource返回一个具体的视图给DispatchServlet10）渲染视图11）展示给用户 SpringMVC 的常用注解 @RequestMapper @Controller @RequestBody @PathVariable @ResponBody SpringBoot 是什么 SpringBoot 是一个Spring旗下的框架，是一种全新的编程规范，他简化了框架的使用，它提供了自动化配置 解决了Spring配置繁杂的问题 是开发者更轻快的进行开发 SpringCloud 的熔断器Hystrix 的作用 当请求后端的服务的失败数量超过了一定比例(默认百分之50) 断路器就会将该服务短路 在一段时间内(默认5秒)所有请求就会直接失败,在时间结束后短路器会设置为半开路的状态 检测到下次请求如果成功则切换成开路状态否则设为闭路状态 一直循环 知道请求成功! 熔断器是为了防止一个服务的宕机避免发送大量无效请求 影响请求系统的吞吐量 从而导致整个系统崩溃! springcloud怎么来实现服务与服务之间的访问 在Springcloud的中 我们是使用Feign 来进行服务间的通信, 通过服务的提供者提供接口 服务的消费者用feign 进行调用 feign怎么实现服务之间的调用的 通过@feignclient上面制定的服务,到eureka上找相应的服务名找到具体的服务,然后feign接口里的远程接口必须跟服务提供者的接口头必须一致,才能访问通 Mybatis 中#{}和${} 的区别 在动态传参的时候 #{}是占位符 ${}是拼接符 在变量替换后#{}会自动加上”” 而${}不会 在Sql 注入中#{}是预编译的所以能防止Sql注入 ${}直接编译不能预防Sql 注入 讲讲Mysql ACID 是什么 Atomicity : 原子性 Consistency : 一致性 Ionsistency : 隔离性 Durability : 持久性 讲讲事务的隔离级别 读未提交 : 一个事务可以读取到,另一个事务未提交 读已提交 : 一个事务提交后,其变更才会被另一个事务读取到 可重复读 : 在一个事务执行的过程中所读取到的数据，和事务启动时所看到的一致。 串行化 : 当操作一行数据时，读写分别都会加锁。当出现读写锁互斥时，会排队串行执行 Mysql 中Char 和VarChar的区别 Char 的长度是固定的 Varchar 是长度可变化的 当Char(10)中传入 的字符只要2个长度的话Char就好用0 填满而Varchar 则会动态改变 Mysql 的常用引擎 Innodb : 提供了数据库的事务支持,也支持行锁和外键 MyISAM : 不支持事务和外键 怎么做Mysql 的性能优化 为查询缓存 当只有一条数据的时候用Limit 1 为常搜索的字段创建索引 避免使用Select * 对表进行垂直拆分 Redis 的持久化方式 RDB 将内存中的数据写入到磁盘中。即在指定目录下生成一 dump.rdb文件 触发条件 save bgsave ,在指定的时间间隔内，执行指定次数的写操作 AOF 它采用日志的形式来记录每个写操作，并追加到文件中 触发条件 根据配置文件触发 ———————————————————— 未完待续 ———————————————]]></content>
      <categories>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[”java核心基础总结“]]></title>
    <url>%2F2019%2F07%2F16%2F%E2%80%9Djava%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%E2%80%9C%2F</url>
    <content type="text"><![CDATA[Java基础学习总结每部分内容会重点写一些常见知识点，方便复习和记忆，但是并不是全部内容，详细的内容请参见具体的文章地址。 面向对象三大特性1234567继承：一般类只能单继承，内部类实现多继承，接口可以多继承封装：访问权限控制public &gt; protected &gt; 包 &gt; private 内部类也是一种封装多态：编译时多态，体现在向上转型和向下转型，通过引用类型判断调用哪个方法（静态分派）。运行时多态，体现在同名函数通过不同参数实现多种方法（动态分派）。 基本数据类型123456789基本类型位数，自动装箱，常量池例如byte类型是1byte也就是8位，可以表示的数字是-128到127，因为还有一个0，加起来一共是256，也就是2的八次方。32位和64位机器的int是4个字节也就是32位，char是1个字节就是8位，float是4个字节，double是8个字节，long是8个字节。所以它们占有字节数是相同的，这样的话两个版本才可以更好地兼容。（应该）基本数据类型的包装类只在数字范围-128到127中用到常量池，会自动拆箱装箱，其余数字范围的包装类则会新建实例 String及包装类12345678String类型是final类型，在堆中分配空间后内存地址不可变。底层是final修饰的char[]数组，数组的内存地址同样不可变。但实际上可以通过修改char[n] = &apos;a&apos;来进行修改，不会改变String实例的内存值，不过在jdk中，用户无法直接获取char[]，也没有方法能操作该数组。所以String类型的不可变实际上也是理论上的不可变。所以我们在分配String对象以后，如果将其 = &quot;abc&quot;，那也只是改变了引用的指向，实际上没有改变原来的对象。StringBuffer和StringBuilder底层是可变的char[]数组，继承父类AbstractStringBuilder的各种成员和方法，实际上的操作都是由父类方法来完成的。 final关键字1234567final修饰基本数据类型保证不可变final修饰引用保证引用不能指向别的对象，否则会报错。final修饰类，类的实例分配空间后地址不可变，子类不能重写所有父类方法。因此在cglib动态代理中，不能为一个类的final修饰的函数做代理，因为cglib要将被代理的类设置为父类，然后再生成字节码。final修饰方法，子类不能重写该方法。 抽象类和接口1234567891 抽象类可以有方法实现。抽象类可以有非final成员变量。抽象方法要用abstract修饰。抽象类可以有构造方法，但是只能由子类进行实例化。2 接口可以用extends加多个接口实现多继承。接口只能有public final类型的成员变量。接口只能有抽象方法，不能有方法体、接口不能实例化，但是可以作为引用类型。 代码块和加载顺序12345假设该类是第一次进行实例化。那么有如下加载顺序静态总是比非静态优先，从早到晚的顺序是：1 静态代码块 和 静态成员变量的顺序根据代码位置前后来决定。2 代码块和成员变量的顺序也根据代码位置来决定3 最后才调用构造方法构造方法 包、内部类、外部类12345678910111 Java项目一般从src目录开始有com.*.*.A.java这样的目录结构。这就是包结构。所以一般编译后的结构是跟包结构一模一样的，这样的结构保证了import时能找到正确的class引用包访问权限就是指同包下的类可见。import 一般加上全路径，并且使用.*时只包含当前目录的所有类文件，不包括子目录。2 外部类只有public和default两种修饰，要么全局可访问，要么包内可访问。3 内部类可以有全部访问权限，因为它的概念就是一个成员变量，所以访问权限设置与一般的成员变量相同。非静态内部类是外部类的一个成员变量，只跟外部类的实例有关。静态内部类是独立于外部类存在的一个类，与外部类实例无关，可以通过外部类.内部类直接获取Class类型。 异常12345678910111213141 异常体系的最上层是Throwable类子类有Error和ExceptionException的子类又有RuntimeException和其他具体的可检查异常。2 Error是jvm完全无法处理的系统错误，只能终止运行。运行时异常指的是编译正确但运行错误的异常，如数组越界异常，一般是人为失误导致的，这种异常不用try catch，而是需要程序员自己检查。可检查异常一般是jvm处理不了的一些异常，但是又经常会发生，比如Ioexception，Sqlexception等，是外部实现带来的异常。3 多线程的异常流程是独立的，互不影响。大型模块的子模块异常一般需要重新封装成外部异常再次抛出，否则只能看到最外层异常信息，难以进行调试。日志框架是异常报告的最好帮手，log4j，slf4j中，在工作中必不可少。 泛型1234567891011Java中的泛型是伪泛型，只在编译期生效，运行期自动进行泛型擦除，将泛型替换为实际上传入的类型。泛型类用class &lt;T&gt; A &#123;&#125;这样的形式表示，里面的方法和成员变量都可以用T来表示类型。泛型接口也是类似的，不过泛型类实现泛型接口时可以选择注入实际类型或者是继续使用泛型。泛型方法可以自带泛型比如void &lt;E&gt; E go();泛型可以使用?通配符进行泛化 Object&lt;?&gt;可以接受任何类型也可以使用 &lt;? extends Number&gt; &lt;? super Integer&gt;这种方式进行上下边界的限制。 Class类和Object类1234567Java反射的基础是Class类，该类封装所有其他类的类型信息，并且在每个类加载后在堆区生成每个类的一个Class&lt;类名&gt;实例，用于该类的实例化。Java中可以通过多种方式获取Class类型，比如A.class,new A().getClass()方法以及Class.forName(&quot;com.?.?.A&quot;)方法。Object是所有类的父类，有着自己的一些私有方法，以及被所有类继承的9大方法。有人讨论Object和Class类型谁先加载谁后加载，因为每个类都要继承Object，但是又得先被加载到堆区，事实上，这个问题在JVM初始化时就解决了，没必要多想。 javac和java12345javac 是编译一个java文件的基本命令，通过不同参数可以完成各种配置，比如导入其他类，指定编译路径等。java是执行一个java文件的基本命令，通过参数配置可以以不同方式执行一个java程序或者是一个jar包。javap是一个class文件的反编译程序，可以获取class文件的反编译结果，甚至是jvm执行程序的每一步代码实现。 反射1234567Java反射包reflection提供对Class，Method，field，constructor等信息的封装类型。通过这些api可以轻易获得一个类的各种信息并且可以进行实例化，方法调用等。类中的private参数可以通过setaccessible方法强制获取。反射的作用可谓是博大精深，JDK动态代理生成代理类的字节码后，首先把这个类通过defineclass定义成一个类，然后用class.for(name)会把该类加载到jvm，之后我们就可以通过，A.class.GetMethod()获取其方法，然后通过invoke调用其方法，在调用这个方法时，实际上会通过被代理类的引用再去调用原方法。 枚举类12345枚举类继承Enum并且每个枚举类的实例都是唯一的。枚举类可以用于封装一组常量，取值从这组常量中取，比如一周的七天，一年的十二个月。枚举类的底层实现其实是语法糖，每个实例可以被转化成内部类。并且使用静态代码块进行初始化，同时保证内部成员变量不可变。 序列化123456789序列化的类要实现serializable接口transient修饰符可以保证某个成员变量不被序列化readObject和writeOject来实现实例的写入和读取。待更新。事实上，一些拥有数组变量的类都会把数组设为transient修饰，这样的话不会对整个数组进行序列化，而是利用专门的方法将有数据的数组范围进行序列化，以便节省空间。 动态代理12345678910111213jdk自带的动态代理可以代理一个已经实现接口的类。cglib代理可以代理一个普通的类。动态代理的基本实现原理都是通过字节码框架动态生成字节码，并且在用defineclass加载类后，获取代理类的实例。一般需要实现一个代理处理器，用来处理被代理类的前置操作和后置操作。在JDK动态代理中，这个类叫做invocationHandler。JDK动态代理首先获取被代理类的方法，并且只获取在接口中声明的方法，生成代理类的字节码后，首先把这个类通过defineclass定义成一个类，然后把该类加载到jvm，之后我们就可以通过，A.class.GetMethod()获取其方法，然后通过invoke调用其方法，在调用这个方法时，实际上会通过被代理类的引用再去调用原方法。而对于cglib动态代理，一般会把被代理类设为代理类的父类，然后获取被代理类中所有非final的方法，通过asm字节码框架生成代理类的字节码，这个代理类很神奇，他会保留原来的方法以及代理后的方法，通过方法数组的形式保存。cglib的动态代理需要实现一个enhancer和一个interceptor，在interceptor中配置我们需要的代理内容。如果没有配置interceptor，那么代理类会调用被代理类自己的方法，如果配置了interceptor，则会使用代理类修饰过的方法。 多线程1234567891011121314151617181920这里先不讲juc包里的多线程类。juc相关内容会在Java并发专题讲解。线程的实现可以通过继承Thread类和实现Runable接口也可以使用线程池。callable配合future可以实现线程中的数据获取。Java中的线程有7种状态，new runable running blocked waiting time_waiting terminateblocked是线程等待其他线程锁释放。waiting是wait以后线程无限等待其他线程使用notify唤醒time_wating是有限时间地等待被唤醒，也可能是sleep固定时间。Thread的join是实例方法，比如a.join(b),则说明a线程要等b线程运行完才会运行。o.wait方法会让持有该对象o的线程释放锁并且进入阻塞状态，notify则是持有o锁对象的线程通知其他等待锁的线程获取锁。notify方法并不会释放锁。注意这两个方法都只能在synchronized同步方法或同步块里使用。synchronized方法底层使用系统调用的mutex锁，开销较大，jvm会为每个锁对象维护一个等待队列，让等待该对象锁的线程在这个队列中等待。当线程获取不到锁时则让线程阻塞，而其他检查notify以后则会通知任意一个线程，所以这个锁时非公平锁。Thread.sleep()，Thread.interrupt()等方法都是类方法，表示当前调用该方法的线程的操作。一个线程实例连续start两次会抛异常,这是因为线程start后会设置标识，如果再次start则判断为错误。 IO流12345IO流也是Java中比较重要的一块，Java中主要有字节流，字符流，文件等。其中文件也是通过流的方式打开，读取和写入的。IO流的很多接口都使用了装饰者模式，即将原类型通过传入装饰类构造函数的方式，增强原类型，以此获得像带有缓冲区的字节流，或者将字节流封装成字符流等等，其中需要注意的是编码问题，后者打印出来的结果可能是乱码哦。IO流与网络编程息息相关，一个socket接入后，我们可以获取它的输入流和输出流，以获取TCP数据包的内容，并且可以往数据报里写入内容，因为TCP协议也是按照流的方式进行传输的，实际上TCP会将这些数据进行分包处理，并且通过差错检验，超时重传，滑动窗口协议等方式，保证了TCP数据包的高效和可靠传输。 网络编程123456789承接IO流的内容IO流与网络编程息息相关，一个socket接入后，我们可以获取它的输入流和输出流，以获取TCP数据包的内容，并且可以往数据报里写入内容，因为TCP协议也是按照流的方式进行传输的，实际上TCP会将这些数据进行分包处理，并且通过差错检验，超时重传，滑动窗口协议等方式，保证了TCP数据包的高效和可靠传输。除了使用socket来获取TCP数据包外，还可以使用UDP的DatagramPacket来封装UDP数据包，因为UDP数据包的大小是确定的，所以不是使用流方式处理，而是需要事先定义他的长度，源端口和目标端口等信息。为了方便网络编程，Java提供了一系列类型来支持网络编程的api，比如URL类，InetAddress类等。后续文章会带来NIO相关的内容，敬请期待。 Java81234567891011接口中的默认方法，接口终于可以有方法实现了，使用注解即可标识出默认方法。lambda表达式实现了函数式编程，通过注解可以声明一个函数式接口，该接口中只能有一个方法，这个方法正是使用lambda表达式时会调用到的接口。Option类实现了非空检验新的日期API各种api的更新，包括chm，hashmap的实现等Stream流概念，实现了集合类的流式访问，可以基于此使用map和reduce并行计算。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>javaSe</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记人生第一次面试]]></title>
    <url>%2F2019%2F07%2F11%2F%E8%AE%B0%E7%AC%AC%E4%B8%80%E6%AC%A1%E9%9D%A2%E8%AF%95%2F</url>
    <content type="text"><![CDATA[​ 昨天去面试了，面试的是Java实习生的岗位,因为是刚毕业,在找工作，所以在拉钩上投了简历，有幸被一家公司给看上了，然后叫我第二天下午两点是否有时间去面试,当时想着贼激动 终于有人邀请我面试,所以满口答应下来了！然后这一天连忙看起来了面试题,并且去公司网站去看了下公司简介 ，感觉公司环境不错！ ​ 到了第二天，漫怀激动地的早早起床,又开始看这面试题,和复习一下原来学过的！到了中午时间，我一点钟就到了公司楼下，然后在楼下坐了一会了,平复下激动的心情，到了一点半的时候上楼了,礼貌的敲了下门，然后就说明自己是面试的,很快一位男生就问我带了简历没，当时有点紧张 直接把两份简历都给了他 , 随后就说先给我一份笔试题 ，在单独的会议上中自己先写一下 ,写完在告诉他！在经过一个小时的奋战我终于把那30题的选择，四题的概述，两题的sql 写完了！期间我不止一次想拿起手机来求救 但是还是忍住了，虽然知道这样可以写的更好(当时会议室中只有我一个人 外部是看不到里面的)但是心理总觉得怪怪的！ ​ 然后将面试题写完交给他 他叫我等几分钟 坐一会,然后拿着我写的面试题看看正确度去了,在等了几分钟后就进来了两个男的 坐在我对面说可以开始面试了，瞬间将我平静的心又开始紧张起来了！首先叫我先自我介绍一下，我就特简单的说了下自己的姓名 年龄 毕业学校 毕业时间和学历 。在听到我毕业了的时候 面试官当时就说他们其实找的是实习生 未毕业，和我说了句你也知道实习生和应届毕业生还是有区别的吧！然后我就en 点了点头 ​ 然后开始问了我一些基础的技术问题 == 和equals 的区别 你说说Spring的是什么东西 HTTP中get 和post 的区别 (这道题笔试中也出现了) int 和Integer 的区别 和它们默认值是啥，然后看到我简历中写到了一个web商城项目 叫我介绍一下 然后自己负责的模块 ！ 项目中前后端交互是怎么实现的 用的是什么技术 这部分我因为紧张 描述的不好，讲的不清楚 ！然后问我登陆注册部分你负责的，你有没有涉及表结构的设计 ，讲讲你怎么设计表结构的 当时我回答的时候回答成user表和其他表的表关系了 等我 等我说完后 面试官说 我问的是user 的设计 有哪些字段 然后我才说了一遍！然后问了下我为什么毕业了找实习生 你和实习生比优势和劣势 在哪 期待薪水 多少 和一些个人情况！然后就说在一个礼拜之内公司会回复你！然后我礼貌的说了下谢谢给我面试机会，面试官也礼貌的说谢谢你来面试，慢走！ 第一次面试总结 这次面试是我第一次正式的面试 所以也收获了一下东西 面试的问题都很基础,所以基础很重要 简历要真实 ，一般问都是对应简历问的 也一定要熟悉 所以我在介绍项目的时候就不熟悉 吃亏 面试前做好准备，平复好心态，别太紧张 我就是因为紧张过度 很多东西都知道但是表述不清楚(缺乏锻炼) 所以一定不要紧张 自我介绍 一定不能太官方 就是像背的一样 自然点 (就是别紧张) 不足之处 太紧张 导致表述不清楚 不是很熟悉自己的简历 被问到就有点懵 更表述不太好 有了第一次面试的话，估计下一次就不会这么紧张了。虽然这次面试应该凉了 但是总体来说体验还是蛮好的，面试官很nice 就像跟你聊天一样 也在引导你 让你心里不要那么紧张 ！有了这次面试经验希望下次能表现好点吧！]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis-持久化]]></title>
    <url>%2F2019%2F07%2F07%2Fredis-%E6%8C%81%E4%B9%85%E5%8C%96%2F</url>
    <content type="text"><![CDATA[Redis 的持久化 —AOF 模式AOF 运行原理(日志的形式) AOF 的三种策略 always (每条策略) always——&gt; 缓存区——&gt; AOF文件 每条命令都会写入硬盘中 everysec(每秒策略） always——&gt; 缓存区——&gt; AOF文件 每秒把缓存区fsync硬盘中 no 根据操作系统决定 三种策略比较| 命令 | always | everysec | no | | —- | ———- | ————————– | —— | | 优点 | 不丢失数据 | 每秒一次fsync 丢失一秒数据 | 不用管 | | 缺点 | IO开销大 | 丢一秒数据 | 不可控 | Redis 的持久化—–Rdb 模式 RDB: 在持久化本地创建一个red后缀的文件, 在恢复时,然后启动载入，等于设置了个快照 触发机制 Sava(同步):这是条同步命令 在执行这条命令后 所有其他的命名必须去排队 等它执行完毕才能 - 在执行save命令后 因为他是条同步命令，其他命令必须等它执行完毕才能执行 所以当数据量过大的时候容易造成阻塞 bgsave (异步) 在执行这条命令后，会返回ok 然后在后台执行 | 命令 | save | bgsave | | ——– | ———————————- | ——————————- | | IO 类型 | 同步 | 异步 | | 是否阻塞 | 是 | 不是(但是阻塞发生在Fork) | | 复杂度 | O(n) | O(n) | | 优缺点 | 不会消耗额为内存，但是会阻塞客户端 | 不阻塞客户端，需要fork 消耗内存 | 自动生成RDB 在某些条件达到的时候，自动生成 (内部生成bgsave) | 配置 | seconds(在指定时间/秒) | changes (改变数据条数) | | —- | ———————- | ———————- | | save | 900 | 1 | | save | 300 | 10 | | save | 60 | 10000 | Rdb 文件配置 dbfilename: dump.rdb(生成的rdb文件名称) dir ./(生成文件的路径) stop-writes-on-bgsave-erro yes (在bgsave 保存的时候是否停止写入) rdbcompression yes (是否已压缩的格式写入rdb文件) rdbchecksum yes (是否rdb文件进行检验) 最佳配置 不使用默认自动生成rdb文件 dbfilename ${port}.rdb 以端口号命名 dir /bigdiskpath 特定的目录 stop-writes-on-bgsave-erro yes bgsave 发生错误的时候停止写入 ​ RDB 总结 RDB 是redis 内存到硬盘的快照，用于持久化 save 通常会阻塞Redis basave 不会阻塞Redis 但是会fork 新进程 save 自动配置满足任一就会被执行 比较耗时耗性能 容易丢失数据 Redis 的主从复制设置主从关系 临时主从关系 SLAVEOF 主ip 主端口 永久主从 redis. config 中添加 SLAVEOF 主ip 主端口 从库只读不写 slaveof-read-only：yes/on 主从复制原理 当主redis和从redis 建立MS 关系的时候，从库会向主发送PSYNC 命令 主库收到PSYNC 命令后会开始在后台保存快照数据(rdb 快照)并且在快照期间写的命令加入缓存，在快照写入完毕的时候将快照和缓存一并发送给从redis 从redis 接收到快照和缓存后 ，载入快照文件并写入缓存命令 之后每次主redis 进行写操作事，都会将命令发送给从redis 从而保证数据的一致性 当redis 宕机后处理 当从redis 宕机时 ，处理方式 从redis 重新启动后会自动加入主从架构中，自动完成同步数据 redis 2.8 就实现类 主从断线后恢复为增量复制 主redis 宕机 当主redis 宕机后，先在从redis 中执行 SLAVEOF NO ONE 命令，断开主从关系并提升为主库，然后重启宕机的主库 并执行SLAVEOF 命令 降为从库,这样数据就能同步起来 Redis 的哨兵机制 哨兵的作用就是对redis 集群的监控，它是一个独立的进程 哨兵的功能 监控主从数据库是否正常 主数据出现的故障后自动将从数据库转为主数据库 原理 启动哨兵命令 Redis -sentinel sentinel.config]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构- 链表]]></title>
    <url>%2F2019%2F05%2F25%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[概述 链表 真正的动态数据结构 最简单的动态数据结构 更好深入了理解引用 更好理解递归 链表 Linked List 数据是储存在节点(Node)中 优缺点 优点：真正的动态,不需要处理固定的容量问题 缺点： 不能随机访问(不能根据索引查找数据) 所以查找较慢 数组和链表的对比 数组最好用于索引有语意的情况 scores[2] 支持快速查询 链表不适索引有语意的情况 最大的有点：动态 用java创建链表1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192package com.zerolg.Linklist;/** * @program: Array * @description: 用java 实现链表 * @author: Gyc * @create: 2019-05-25 11:24 **/public class LinkList&lt;E&gt; &#123; private int size; private Node head; public LinkList() &#123; head = null; size = 0; &#125; /** * 获取链表的元素个数 **/ public int getSize() &#123; return size; &#125; /** * 判断链表是否为空 **/ public boolean isEmpty() &#123; return size != 0; &#125; /** * 向链表头添加元素 **/ public void addFrist(E e) &#123; Node node = new Node(e); node.next = head; head = node; size++; &#125; /** * 在index在中添加一个元素 **/ public void add(int index, E e) throws Exception &#123; if (index &lt; 0 || index &gt; size) &#123; throw new Exception("索引错了"); &#125; if (index == 0) &#123; addFrist(e); &#125; else &#123; Node prev = head; for (int i = 0; i &lt; index - 1; i++) &#123; prev = prev.next; &#125; Node node = new Node(e); node.next = prev.next; prev.next = node; size++; &#125; &#125; /**在尾部添加元素**/public void addlist(E e) throws Exception &#123; add(size, e);&#125; // 链表的内部节点 private class Node &#123; public E e; public Node next; public Node(E e, Node next) &#123; this.e = e; this.next = next; &#125; public Node(E e) &#123; this(e, null); &#125; public Node() &#123; this(null, null); &#125; @Override public String toString() &#123; return e.toString(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组实现队列]]></title>
    <url>%2F2019%2F05%2F23%2F%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[概述 队列也是一线性结构 相对数组,队列对应的操作是数组的子集 只能从一端添加元素,一端另一端取出元素 是先进先出的(排队一样)数据结构(First In First Out) 用动态数组实现队列导入数组123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236package com.zerolg.Queue;/** * @program: com.zerolg.Array.Array * @author: Gyc 数组 * @create: 2019-05-20 10:12 **/public class Array&lt;E&gt; &#123; /** * 初始数组 */ private E[] data; // 数组当前个数 private int size; public Array(Integer capaticy) &#123; data = (E[]) new Object[capaticy]; size = 0; &#125; public Array() &#123; //默认10的容量 this(10); &#125; /** * 获取数组中有多少个容量 * * @return */ public int getSize() &#123; return size; &#125; /** * 获取容量大小 * * @return int */ public int getCapaticy() &#123; return data.length; &#125; /** * 判断数组是否为空 * * @return */ public boolean isemply() &#123; return size == 0; &#125; /** * 向数组尾部中添加元素 * * @param e * @throws Exception */ public void addlist(E e) throws Exception &#123; /* if (size == data.length) &#123; throw new Exception("数组中没有容量了"); &#125; data[size] = e; size++;*/ add(size, e); &#125; /** * 往头部添加数据 * * @param e * @throws Exception */ public void addfrist(E e) throws Exception &#123; add(0, e); &#125; /** * 往指定位置添加元素 * * @param index * @param e */ public void add(int index, E e) throws Exception &#123; if (index &lt; 0 || index &gt; size) &#123; throw new Exception("索引应该小于" + size); &#125; if (size == data.length) &#123; resize((int) (data.length * 1.5)); &#125; for (int i = size - 1; i &gt;= index; i--) &#123; data[i + 1] = data[i]; &#125; data[index] = e; size++; &#125; /** * 获取指定位置的元素 * * @param index * @return */ public E get(int index) throws Exception &#123; if (index &lt; 0 || index &gt;= size) &#123; throw new Exception("索引不应该小于0和大于" + size); &#125; return data[index]; &#125;//获取第一个元素 public E getfrist() throws Exception &#123; return get(0); &#125; //获取最后一个元素 public E getlast() throws Exception &#123; return get(size - 1); &#125; /** * 设置指定位置的元素 * * @param index * @param e * @return * @throws Exception */ public void set(int index, E e) throws Exception &#123; if (index &lt; 0 || index &gt;= size) &#123; throw new Exception("索引不应该小于0和大于" + size); &#125; data[index] = e; &#125; /** * 数据中是否存在该元素 * * @param e * @return */ public boolean contains(E e) &#123; for (int i = 0; i &lt; size; i++) &#123; if (data[i].equals(e)) &#123; return true; &#125; &#125; return false; &#125; /** * 查看该元素索引 * * @param e * @return */ public int find(E e) &#123; for (int i = 0; i &lt; size; i++) &#123; if (data[i].equals(e)) &#123; return i; &#125; &#125; return -1; &#125; /** * 删除元素 * * @param index */ public E remove(int index) throws Exception &#123; if (index &lt; 0 || index &gt; size) &#123; throw new Exception("索引应该小于" + size); &#125; for (int i = index + 1; i &lt; size; i++) &#123; data[i - 1] = data[i]; &#125; if (size &lt;= data.length / 2) &#123; resize(data.length / 2); &#125; size--; data[size] = null; return data[index]; &#125; //从数组中删除第后元素 public E removelast() throws Exception &#123; remove(size - 1); return get(size - 1); &#125; //从数组中删除第一个元素 public void removefrist() throws Exception &#123; remove(0); &#125; //从数组中删除元素e public void removeElment(E e) throws Exception &#123; int i = find(e); if (i != -1) &#123; remove(i); &#125; &#125; @Override public String toString() &#123; StringBuilder str = new StringBuilder(); str.append(String.format("Array: size= %d , capacity= %d\n", size, data.length)); str.append('['); for (int i = 0; i &lt; size; i++) &#123; str.append(data[i]); if (i != size - 1) &#123; str.append(","); &#125; &#125; str.append("]"); return str.toString(); &#125; // 动态扩容 private void resize(int newCapacity) &#123; E[] newdata = (E[]) new Object[newCapacity]; for (int i = 0; i &lt; size; i++) &#123; newdata[i] = data[i]; &#125; data = newdata; &#125;&#125; 创建队列实现12345678910111213141516171819202122232425262728293031package com.zerolg.Queue;/** * @Author Gyc * @Description //队列 * @Da«te 10:18 2019-05-23 **/public interface Queue&lt;E&gt; &#123; /** * 获取队列中的元素个数 **/ int Size(); /** * 判断队列中的是否有 **/ boolean isEmpty(); /** * 取出队列最后个元素 **/ E dequeue() throws Exception; /** * 获取队列以一个元素 **/ E getFront() throws Exception;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package com.zerolg.Queue;/** * @program: Array * @description: 数组实现队列 * @author: Gyc * @create: 2019-05-23 10:35 **/public class ArratQueue&lt;E&gt; implements Queue&lt;E&gt; &#123; private Array&lt;E&gt; array; public ArratQueue() &#123; array = new Array&lt;&gt;(); &#125; public ArratQueue(int capaticy) &#123; array = new Array&lt;&gt;(capaticy); &#125; /** * 获取队列中的元素个数 **/ @Override public int Size() &#123; return array.getSize(); &#125; /** * 判断队列中的是否有 **/ @Override public boolean isEmpty() &#123; return array.isemply(); &#125; /** * 取出队列最后个元素 **/ @Override public E dequeue() throws Exception &#123; return array.removelast(); &#125; /** * 获取队列以一个元素 **/ @Override public E getFront() throws Exception &#123; return array.getfrist(); &#125; public String toString() &#123; StringBuilder str = new StringBuilder(); str.append("Queue"); str.append("Front["); for (int i = 0; i &lt; array.getSize(); i++) &#123; try &#123; str.append(array.get(i)); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; if (i != array.getSize() - 1) &#123; str.append(","); &#125; &#125; str.append("] tail"); return str.toString(); &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构栈]]></title>
    <url>%2F2019%2F05%2F22%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A0%88%2F</url>
    <content type="text"><![CDATA[栈 Stack 栈也是一种线性结构 相对数组，栈对应的操作是数组的子集 只能从一端添加元素，也只能从一端取出元素(栈顶) 后进先出的数据结构 栈的应用 undo (撤销) 程序调用的系统栈(子函数的调用) 括号匹配 基于动态数组代码实现 基于动态数组 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236 package com.zerolg.Stack;/** * @program: com.zerolg.Array.Array * @author: Gyc 数组 * @create: 2019-05-20 10:12 **/public class Array&lt;E&gt; &#123; /** * 初始数组 */ private E[] data; // 数组当前个数 private int size; public Array(Integer capaticy) &#123; data = (E[]) new Object[capaticy]; size = 0; &#125; public Array() &#123; //默认10的容量 this(10); &#125; /** * 获取数组中有多少个容量 * * @return */ public int getSize() &#123; return size; &#125; /** * 获取容量大小 * * @return int */ public int getCapaticy() &#123; return data.length; &#125; /** * 判断数组是否为空 * * @return */ public boolean isemply() &#123; return size == 0; &#125; /** * 向数组尾部中添加元素 * * @param e * @throws Exception */ public void addlist(E e) throws Exception &#123; /* if (size == data.length) &#123; throw new Exception("数组中没有容量了"); &#125; data[size] = e; size++;*/ add(size, e); &#125; /** * 往头部添加数据 * * @param e * @throws Exception */ public void addfrist(E e) throws Exception &#123; add(0, e); &#125; /** * 往指定位置添加元素 * * @param index * @param e */ public void add(int index, E e) throws Exception &#123; if (index &lt; 0 || index &gt; size) &#123; throw new Exception("索引应该小于" + size); &#125; if (size == data.length) &#123; resize((int) (data.length * 1.5)); &#125; for (int i = size - 1; i &gt;= index; i--) &#123; data[i + 1] = data[i]; &#125; data[index] = e; size++; &#125; /** * 获取指定位置的元素 * * @param index * @return */ public E get(int index) throws Exception &#123; if (index &lt; 0 || index &gt;= size) &#123; throw new Exception("索引不应该小于0和大于" + size); &#125; return data[index]; &#125;//获取第一个元素 public E getfrist() throws Exception &#123; return get(0); &#125; //获取最后一个元素 public E getlast() throws Exception &#123; return get(size - 1); &#125; /** * 设置指定位置的元素 * * @param index * @param e * @return * @throws Exception */ public void set(int index, E e) throws Exception &#123; if (index &lt; 0 || index &gt;= size) &#123; throw new Exception("索引不应该小于0和大于" + size); &#125; data[index] = e; &#125; /** * 数据中是否存在该元素 * * @param e * @return */ public boolean contains(E e) &#123; for (int i = 0; i &lt; size; i++) &#123; if (data[i].equals(e)) &#123; return true; &#125; &#125; return false; &#125; /** * 查看该元素索引 * * @param e * @return */ public int find(E e) &#123; for (int i = 0; i &lt; size; i++) &#123; if (data[i].equals(e)) &#123; return i; &#125; &#125; return -1; &#125; /** * 删除元素 * * @param index */ public E remove(int index) throws Exception &#123; if (index &lt; 0 || index &gt; size) &#123; throw new Exception("索引应该小于" + size); &#125; for (int i = index + 1; i &lt; size; i++) &#123; data[i - 1] = data[i]; &#125; if (size &lt;= data.length / 2) &#123; resize(data.length / 2); &#125; size--; data[size] = null; return data[index]; &#125; //从数组中删除第后元素 public E removelast() throws Exception &#123; remove(size - 1); return get(size - 1); &#125; //从数组中删除第一个元素 public void removefrist() throws Exception &#123; remove(0); &#125; //从数组中删除元素e public void removeElment(E e) throws Exception &#123; int i = find(e); if (i != -1) &#123; remove(i); &#125; &#125; @Override public String toString() &#123; StringBuilder str = new StringBuilder(); str.append(String.format("Array: size= %d , capacity= %d\n", size, data.length)); str.append('['); for (int i = 0; i &lt; size; i++) &#123; str.append(data[i]); if (i != size - 1) &#123; str.append(","); &#125; &#125; str.append("]"); return str.toString(); &#125; // 动态扩容 private void resize(int newCapacity) &#123; E[] newdata = (E[]) new Object[newCapacity]; for (int i = 0; i &lt; size; i++) &#123; newdata[i] = data[i]; &#125; data = newdata; &#125;&#125; 栈的基本实现1234567891011121314151617181920212223242526272829303132package com.zerolg.Stack;public interface Stack&lt;E&gt; &#123; /** * 获取栈的中的元素个数 * * @return */ int getSize(); /** * 判断栈中有没有这元素 * * @return */ boolean isEmpty(); /** * 添加元素 **/ void push(E e) throws Exception; /** * 取出元素 **/ E pop() throws Exception; /** * 查看栈顶元素 **/ E peek() throws Exception;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091package com.zerolg.Stack;/** * @program: Array * @description: 基于数组实现栈 * @author: Gyc * @create: 2019-05-22 21:38 **/public class ArrayStatck&lt;E&gt; implements Stack&lt;E&gt; &#123; Array&lt;E&gt; array; public ArrayStatck(int capacity) &#123; array = new Array&lt;&gt;(capacity); &#125; ArrayStatck() &#123; array = new Array&lt;&gt;(); &#125; /** * 获取栈中多少元素 **/ @Override public int getSize() &#123; return array.getSize(); &#125; /** * 获取栈中是否存在元素 **/ @Override public boolean isEmpty() &#123; return array.isemply(); &#125; /** * 添加元素 * * @param o */ @Override public void push(E e) throws Exception &#123; array.addlist(e); &#125; /** * 查看栈容量 **/ public int getCapacity() &#123; return array.getCapaticy(); &#125; /** * 取出元素 **/ @Override public E pop() throws Exception &#123; return array.removelast(); &#125; /** * 查看栈顶元素 **/ @Override public E peek() throws Exception &#123; return array.getlast(); &#125; public String toString() &#123; StringBuilder str = new StringBuilder(); str.append("Stack"); str.append('['); for (int i = 0; i &lt; array.getSize(); i++) &#123; try &#123; str.append(array.get(i)); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; if (i != array.getSize() - 1) &#123; str.append(","); &#125; &#125; str.append("] top"); return str.toString(); &#125;&#125; 用栈实现括号匹配12345678910111213141516171819202122232425262728293031323334353637383940414243 package com.zerolg;import java.util.Stack;/** * @program: Array * @description: Solution * @author: Gyc * @create: 2019-05-23 00:07 **/public class Solution &#123; Stack&lt;Character&gt; stack = new Stack&lt;&gt;(); public static void main(String[] args) &#123; Solution solution = new Solution(); boolean isvalid = solution.isvalid("()[]&#123;&#125;"); System.out.println(isvalid); &#125; public boolean isvalid(String s) &#123; for (int i = 0; i &lt; s.length(); i++) &#123; char c = s.charAt(i); if (c == '(' || c == '&#123;' || c == '[') stack.push(c); else &#123; if (stack.isEmpty()) return false; char pop = stack.pop(); if (c == ')' &amp;&amp; pop != '(') return false; if (c == ']' &amp;&amp; pop != '[') return false; if (c == '&#125;' &amp;&amp; pop != '&#123;') return false; &#125; &#125; return stack.isEmpty(); &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记录ssm整合中不能加载mybatis的xml文件]]></title>
    <url>%2F2019%2F05%2F17%2F%E8%AE%B0%E5%BD%95ssm%E6%95%B4%E5%90%88%E4%B8%AD%E4%B8%8D%E8%83%BD%E5%8A%A0%E8%BD%BDmybatis%E7%9A%84xml%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[记录一下在复习ssm 整合的时候 一直导致不能加载mybatis.xml 文件 导致的无法绑定 1：检查xml文件所在的package名称是否和interface对应的package名称一一对应 2：检查xml文件的namespace是否和xml文件的package名称一一对应 3：检查函数名称能否对应上 4：去掉xml文件中的中文注释 在百度N个小时的时候后 按以上的方法一一试了一遍后问题还是没有解决！猜想是不是没有加载到这个文件 才导致没有找到才不能绑定的 然后就去尝试看了下发布过后的项目结构 ！ 发现*.xml 没有发布到classes目录下 ！ 导致原因idea中我将mapper类型是source，而xml文件在发布时不会编译，同时也不会发布到target中，导致项目运行时找不到mapper.xml文件。 解决方法]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux基本命令]]></title>
    <url>%2F2019%2F05%2F11%2FLinux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[命令的基本使用`[root@localhost] root: 用户名 ~ 表示当前地址 localhost 主机名 命令的基本格式 命令[选项] [参数] 查询目录的内容命令格式ls[选项] [文件或者目录] 选项： -a 所有文件 -l 查看详情 -d 查看目录属性 -h 显示文件大小 文件夹处理命令 创建目录12mkdir - p[目录名]-p 表述递归建文件夹 切换目录123456789cd [目录]cd ~ 进入当前用户目录cd - 进入上次目录cd .. 进入上一级目录pwd 查看当前目录所在位置 删除目录123456789101112131415161718rmdir [目录]rmdir -rf[目录] 删除目录中所以的文件命令：rm [-rf] 目录删除文件：rm 文件 删除当前目录下的文件rm -f 文件 删除当前目录的的文件（不询问）删除目录：rm -r aaa 递归删除当前目录下的aaa目录rm -rf aaa 递归删除当前目录下的aaa目录（不询问）全部删除：rm -rf * 将当前目录下的所有目录和文件全部删除rm -rf /* 【自杀命令！慎用！慎用！慎用！】将根目录下的所有文件全部删除注意：rm不仅可以删除目录，也可以删除其他文件或压缩包，为了方便大家的记忆，无论删除任何目录或文件，都直接使用 rm -rf 目录/文件/压缩包 复制目录1234cp[选项][原文件路径][更改文件路径] 选项： -r 复制目录 -p 连文件属性一起复制 重命名 和剪切MV123456789一、重命名目录 命令：mv 当前目录 新目录 例如：mv aaa bbb 将目录aaa改为bbb 注意：mv的语法不仅可以对目录进行重命名而且也可以对各种文件，压缩包等进行 重命名的操作二、剪切目录 命令：mv 目录名称 目录的新位置 示例：将/usr/tmp目录下的aaa目录剪切到 /usr目录下面 mv /usr/tmp/aaa /usr 注意：mv语法不仅可以对目录进行剪切操作，对文件和压缩包等都可执行剪切操作 常见文件作用 12345678/根目录/bin 命令保存目录/boot 启动目录/dev 设备文件命令/etc 配置文件保存目录/home 家目录/lib 系统保存命令/mnt 系统挂载命令文件的操作 文件的新建 1touch 文件名 文件的删除 1rm -rf 文件名 文件的修改 12345678910111213141516171819202122vi编辑器的3种模式】 基本上vi可以分为三种状态，分别是命令模式（command mode）、插入模式（Insert mode）和底行模式（last line mode），各模式的功能区分如下：1) 命令行模式command mode） 控制屏幕光标的移动，字符、字或行的删除，查找，移动复制某区段及进入Insert mode下，或者到 last line mode。 命令行模式下的常用命令： 【1】控制光标移动：↑，↓，j 【2】删除当前行：dd 【3】查找：/字符 【4】进入编辑模式：i o a 【5】进入底行模式：: 2) 编辑模式（Insert mode） 只有在Insert mode下，才可以做文字输入，按「ESC」键可回到命令行模式。 编辑模式下常用命令： 【1】ESC 退出编辑模式到命令行模式； 3) 底行模式（last line mode） 将文件保存或退出vi，也可以设置编辑环境，如寻找字符串、列出行号……等。 底行模式下常用命令： 【1】退出编辑： :q 【2】强制退出： :q! 【3】保存并退出： :wq 文件的查看12345678 ### 查看最后一屏 cat[文件名]### 百分比查看more [文件名称]### less 翻页查看less[文件名]### tail 指定行数查看tail -[行数][文件名] 查看进程1ps -ef 查看所有正在运行的进程 结束进程123kill pid(进程号)### 强制结束kill - 9 pid(进程号) 压缩和解压命令 zip 格式 123456### 压缩文件zip[压缩文件名][原文件]## 压缩目录zip -r [压缩文件名][原文件]### 解压unzip[压缩文件名] gz格式 12345678### 压缩文件gzip[原文件]### 压缩文件夹gzip -r [目录]### 解压guzip [文件]### 解压目录guzip -r [文件目录] tar 123tar-cvf 打包文件名 原文件### 解压tar -xvf [解缩文件名] tar.gz 123tar -zcvf 压缩包名.targz 原文件### 解压tar -zxvf 解压包名.targz 关机重启1234567shutdown[选项][时间]选项： - c 取消前一个关机命令 -h now 立即关机 -r now 立即重启 reboot 重启启动 logout 退出登入 ####]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-单例模式-破坏单例模式]]></title>
    <url>%2F2019%2F05%2F11%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-%E7%A0%B4%E5%9D%8F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[单例设计模式核心就是:保证只实例化一个对象 但是有没有办法破坏呢 和该如何防止 序列化破坏单例 和防止 创建饿汉单例设计模式 12345678910111213141516171819202122package com.zerolg.designmode.designmode.singletonpattern;/** * @program: design * @description: 饿汉设计模式 * @author: Gyc * @create: 2019-05-11 10:16 **/public class HungrySingleton &#123; private static HungrySingleton hungrySingleton; static &#123; hungrySingleton = new HungrySingleton(); &#125; private HungrySingleton() &#123; &#125; public static HungrySingleton getHungrySingleton() &#123; return hungrySingleton; &#125;&#125; 序列化和反序列化 1234567891011121314151617public class Test &#123; public static void main(String[] args) throws IOException, ClassNotFoundException &#123;// 序列化和反序列化破坏单例// 创建序列化对象 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("singLeton_file"));// 获取单例对象 HungrySingleton instance = HungrySingleton.getHungrySingleton();// 序列化对象 oos.writeObject(instance);// 创建反序列化对象 ObjectInputStream ois = new ObjectInputStream(new FileInputStream(new File("singLeton_file")));// 反序列对象 HungrySingleton newinstance = (HungrySingleton) ois.readObject();// 对比两对象是否为同一对象 System.out.println(instance == newinstance); &#125;&#125; 测试结果报错，是忘记了要序列化对象必须实现Serializable类 所以去单例类中实现序列化类 当实例化 进行判断发现该对象不是同一对象 所以破坏了单例中只能实例一个对象的原则 产生原因：这是jdk中序列化和反序列化的时候进行处理 判断如果没用readResolve() 方法 则会从新利用反射实例化 该背序列化的对象 参考 jdk关于ObjectInputStream的readObject()方法 调用栈 readObject---&gt;readObject0---&gt;readOrdinaryObject---&gt;checkResolve 详请参考[单例模式序列化反序列化单例失效问题] 解决方法123456789101112131415161718public class HungrySingleton implements Serializable &#123; private static HungrySingleton hungrySingleton; static &#123; hungrySingleton = new HungrySingleton(); &#125; private HungrySingleton() &#123; &#125; public static HungrySingleton getHungrySingleton() &#123; return hungrySingleton; &#125; public Object readResolve() &#123; return hungrySingleton; &#125;&#125; 在添加 public Object readResolve() { return hungrySingleton; } 代码段后 我们在查看测试结果发现有实现单例了 反射破坏单例设计模式饿汉式12345678910111213141516171819202122/** * @program: design * @description: 单例破坏单例 * @author: Gyc * @create: 2019-05-11 11:01 **/public class Test2 &#123; public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException &#123;// 单例获取对象 HungrySingleton instance = HungrySingleton.getHungrySingleton(); Class hsl=HungrySingleton.class;// 获取反射对象 Constructor hslClass = hsl.getDeclaredConstructor();// 开启暴力破解 hslClass.setAccessible(true);// 利用反射对象实例化 HungrySingleton newInstance= (HungrySingleton) hslClass.newInstance();// 比较两对象是否为同一对象 System.out.println("两对象是否还是同一实例" + (instance == newInstance)); &#125;&#125; 所以在饿汉单例设计模式下 利用反射也可以让单例失效 防止方法 饿汉模式是在类加载的时候就生成了实例 所以我们可以在他调用构照的时候 进行判断 是否创建个实例 如果是被外部调用构照的 直接抛出异常 12345private HungrySingleton() &#123; if (hungrySingleton != null) &#123; throw new RuntimeException("单例设计模式不允许反射调用"); &#125;&#125; 所以在此测试的时候就会抛出异常 懒汉式 创建懒汉式单例对象 123456789101112131415161718192021222324/** * @program: design * @description: 懒汉式 线程不安全的 重点与懒加载 只有使用的时候才创建对象 * @author: Gyc * @create: 2019-05-08 11:55 **/public class LazySingleton &#123; private static LazySingleton lazySingleton = null; private LazySingleton() &#123; &#125; /** * synchronized 加入synchronized 后性能降低 线程安全 * @return */ public static synchronized LazySingleton getInstance() &#123; if (lazySingleton == null) &#123; lazySingleton = new LazySingleton(); &#125; return lazySingleton; &#125;&#125; 利用反射测试 12345678910111213 public void test2() throws IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchMethodException &#123; LazySingleton instance = LazySingleton.getInstance(); Class hsl = LazySingleton.class;// 获取反射对象 Constructor hslClass = hsl.getDeclaredConstructor();// 开启暴力破解 hslClass.setAccessible(true);// 利用反射对象实例化 LazySingleton newInstance = (LazySingleton) hslClass.newInstance();// 比较两对象是否为同一对象 System.out.println("两对象是否还是同一实例" + (instance == newInstance)); &#125;&#125; 结果不除意外肯定也是false 那我们试试和前面一样在构照器中判断是否为空再抛出异常看是否会抛出异常 12345private LazySingleton() &#123; if (lazySingleton != null) &#123; throw new RuntimeException("单例设计模式不允许反射调用"); &#125; &#125; 测试运行 反射和单例获取对象运行顺序调换 ,却没有抛出异常,反射创建到了实例 原因是因为 懒汉设计模式是 懒加载的 只要调用的时候才创建实例 所以当反射运行在前的时候 构照判断该对象为空 所以不会抛出异常 所以反射就实例化了该对象 然后在使用单例的时候又创建的实例 在判断的时候创建两个实例 ！]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>单例设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[”设计模式-单例设计模式]]></title>
    <url>%2F2019%2F05%2F08%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[概述 单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。 注： 单例只能存在一个实例 单例类必须自己创建自己的唯一实例 单例类必须给所有其他对象提供这一实例 单例设计模式之懒汉式单例设计模式之懒汉式(线程不安全方式)12345678910111213public class Singleton&#123; private Singleton instance; private Singleton()&#123;&#125; public static Singleton getInstance()&#123; if(instance==null)&#123; return instance=new Singleton(); &#125; return instance; &#125; &#125; 单例设计模式之懒汉式(线程安全方式)12345678910111213public class Singleton&#123; private Singleton instance; private Singleton()&#123;&#125; public synchronized static Singleton getInstance()&#123; if(instance==null)&#123; return instance=new Singleton(); &#125; return instance; &#125; &#125; 两种优缺点对比 线程不安全方式: 效率高,但是不支持多线程(单线程中推荐) 线程安全方式:效率极低(必须加锁),但是能在多线程中运行 懒汉式的缺点 没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化 懒汉式的优点 只有在第一次调用才创建对象 避免内存浪费 避免对资源的多重占用 单例设计模式之双检锁注： Jdk1.5起支持 线程安全 这种方式采用双锁机制，安全且在多线程情况下能保持高性能。 1234567891011121314public class Singleton&#123; private volatile static Singleton instance; private Singleton()&#123;&#125;； public void getInstance()&#123; if(instance==null)&#123; synchronized (Singleton.class) &#123; if(instance=null)&#123; instance=new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; 单例设计模式之饿汉式 线程安全 支持多线程 没有加锁,效率提高 类加载时就加载浪费内存(容易产生垃圾对象) 1234567public class Singleton&#123; public static Singleton instance=new Singleton(); private Singleton()&#123;&#125;&#125;public static Singleton getInstance() &#123; return instance; &#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>单例设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-工厂方法总结]]></title>
    <url>%2F2019%2F05%2F06%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[简单工厂 工厂方法 抽象工厂 共同点 都是创建型 用户不需要知道产品创建过程只需要返回的产品对象 不同点 简单工厂:用来生产同一等级结构中的任意产品(完全没解耦) 工厂方法:用来生产同一等级结构中的固定产品(将工厂抽象出来) 抽象工厂：用来生产不同产品族的全部产品(完全解耦 产品和工厂都解耦出来)]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>工厂方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-工厂模式-抽象工厂模式]]></title>
    <url>%2F2019%2F05%2F06%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[抽象工厂-定义与类型 定义: 抽象工厂模式提供一个创建一系列相关或者相互依赖对象的接口 无序指定他们指定的类 类型: 创建型 适用场景 客户端不依赖产品实例如何被创建，实现等细节 强调一系列相关的产品对象(属于同一产品族) 一起使用创建对象需要大量重复的代码 提供一个产品类的库,所有的产品以同样的接口出现,从而使客户端不依赖于具体实现 代码实现 创建课程 视频接口 手记接口(抽象产品) 1234567891011121314151617181920212223242526/** * @Author Gyc * @Description 课程工厂 产品族工厂 课程=视频+手记 * @Date 21:36 2019-05-06 * @Param * @return **/public interface CourseFactory &#123; public abstract Video geteVide(); public abstract Article getArticle();&#125;/** * @program: design * @description: 视频类 * @author: Gyc * @create: 2019-05-06 21:39 **/public interface Video &#123; public abstract void produce();&#125;public interface Article &#123; public abstract void produce();&#125; 创键java视频实现类,java手记实现类 python 视频实现类 和python 手记实现类(具体产品) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * @program: design * @description: java 视频 * @author: Gyc * @create: 2019-05-06 21:43 **/public class JavaVidoe implements Video &#123; public void produce() &#123; System.out.println("录制java视频"); &#125;&#125;/** * @program: design * @description: java手记 * @author: Gyc * @create: 2019-05-06 21:45 **/public class JavaArticle implements Article &#123; public void produce() &#123; System.out.println("编写java手记"); &#125;&#125;/** * @program: design * @description: Python 视频 * @author: Gyc * @create: 2019-05-06 21:47 **/public class PythonVideo implements Video &#123; public void produce() &#123; System.out.println("录制Pythion视频"); &#125;&#125;/** * @program: design * @description: Python 手记 * @author: Gyc * @create: 2019-05-06 21:48 **/public class PythonArticle implements Article &#123; public void produce() &#123; System.out.println("编写Python 手记"); &#125;&#125; 创建课程工厂(抽象工厂) 1234567891011/** * @Author Gyc * @Description 课程工厂 产品族工厂 课程=视频+手记 * @Date 21:36 2019-05-06 * @Param * @return **/public interface CourseFactory &#123; public abstract Video geteVide(); public abstract Article getArticle();&#125; 创建java课程工厂 python 课程工厂(具体工厂) 12345678910111213141516171819202122232425262728293031323334/** * @program: design * @description: java课程工厂 * @author: Gyc * @create: 2019-05-06 21:46 **/public class JavaCourseFactiory implements CourseFactory &#123; public Video geteVide() &#123; return new JavaVidoe(); &#125; public Article getArticle() &#123; return new JavaArticle(); &#125;&#125;/** * @program: design * @description: Python 视频工厂 * @author: Gyc * @create: 2019-05-06 21:49 **/public class PythonCourseFactory implements CourseFactory &#123; public Video geteVide() &#123; return new PythonVideo(); &#125; public Article getArticle() &#123; return new PythonArticle(); &#125;&#125; 创建测试 12345678910111213/** * @program: design * @description: 测试 * @author: Gyc * @create: 2019-05-06 21:54 **/public class Test &#123; public static void main(String[] args) &#123; CourseFactory courseFactory=new JavaCourseFactiory(); courseFactory.getArticle().produce(); courseFactory.geteVide().produce(); &#125;&#125; UML类图 优点分析 抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易。所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。另外，应用抽象工厂模式可以实现高内聚低耦合的设计目的，因此抽象工厂模式得到了广泛的应用。 当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。这对一些需要根据当前环境来决定其行为的软件系统来说，是一种非常实用的设计模式。 增加新的具体工厂和产品族很方便，无须修改已有系统，符合“开闭原则”。 缺点分析 在添加新的产品对象时，难以扩展抽象工厂来生产新种类的产品，这是因为在抽象工厂角色中规定了所有可能被创建的产品集合，要支持新种类的产品就意味着要对该接口进行扩展，而这将涉及到对抽象工厂角色及其所有子类的修改，显然会带来较大的不便。 开闭原则的倾斜性（增加新的工厂和产品族容易，增加新的产品等级结构麻烦） 适用场景分析 一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是重要的。 系统中有多于一个的产品族，而每次只使用其中某一产品族 属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来 系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>工厂模式</tag>
        <tag>抽象工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java中操控Cookie 工具类]]></title>
    <url>%2F2019%2F04%2F23%2Fjava%E4%B8%AD%E6%93%8D%E6%8E%A7Cookie%20%E5%B7%A5%E5%85%B7%E7%B1%BB.MD%2F</url>
    <content type="text"><![CDATA[CookieUtils123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225package com.zerolg.myshop.commons.utils;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.UnsupportedEncodingException;import java.net.URLDecoder;import java.net.URLEncoder;/** * @program: Myshop * @description: CookieUtil 的工具类 * @author: Gyc * @create: 2019-04-23 09:13 **/public class CookieUtils &#123; /** * 得到Cookie的值, 不编码 * * @param request * @param cookieName * @return */ public static String getCookieValue(HttpServletRequest request, String cookieName) &#123; return getCookieValue(request, cookieName, false); &#125; /** * 得到Cookie的值, * * @param request * @param cookieName * @return */ public static String getCookieValue(HttpServletRequest request, String cookieName, boolean isDecoder) &#123; Cookie[] cookieList = request.getCookies(); if (cookieList == null || cookieName == null) &#123; return null; &#125; String retValue = null; try &#123; for (int i = 0; i &lt; cookieList.length; i++) &#123; if (cookieList[i].getName().equals(cookieName)) &#123; if (isDecoder) &#123; retValue = URLDecoder.decode(cookieList[i].getValue(), "UTF-8"); &#125; else &#123; retValue = cookieList[i].getValue(); &#125; break; &#125; &#125; &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; return retValue; &#125; /** * 得到Cookie的值, * * @param request * @param cookieName * @return */ public static String getCookieValue(HttpServletRequest request, String cookieName, String encodeString) &#123; Cookie[] cookieList = request.getCookies(); if (cookieList == null || cookieName == null) &#123; return null; &#125; String retValue = null; try &#123; for (int i = 0; i &lt; cookieList.length; i++) &#123; if (cookieList[i].getName().equals(cookieName)) &#123; retValue = URLDecoder.decode(cookieList[i].getValue(), encodeString); break; &#125; &#125; &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; return retValue; &#125; /** * 设置Cookie的值 不设置生效时间默认浏览器关闭即失效,也不编码 */ public static void setCookie(HttpServletRequest request, HttpServletResponse response, String cookieName, String cookieValue) &#123; setCookie(request, response, cookieName, cookieValue, -1); &#125; /** * 设置Cookie的值 在指定时间内生效,但不编码 */ public static void setCookie(HttpServletRequest request, HttpServletResponse response, String cookieName, String cookieValue, int cookieMaxage) &#123; setCookie(request, response, cookieName, cookieValue, cookieMaxage, false); &#125; /** * 设置Cookie的值 不设置生效时间,但编码 */ public static void setCookie(HttpServletRequest request, HttpServletResponse response, String cookieName, String cookieValue, boolean isEncode) &#123; setCookie(request, response, cookieName, cookieValue, -1, isEncode); &#125; /** * 设置Cookie的值 在指定时间内生效, 编码参数 */ public static void setCookie(HttpServletRequest request, HttpServletResponse response, String cookieName, String cookieValue, int cookieMaxage, boolean isEncode) &#123; doSetCookie(request, response, cookieName, cookieValue, cookieMaxage, isEncode); &#125; /** * 设置Cookie的值 在指定时间内生效, 编码参数(指定编码) */ public static void setCookie(HttpServletRequest request, HttpServletResponse response, String cookieName, String cookieValue, int cookieMaxage, String encodeString) &#123; doSetCookie(request, response, cookieName, cookieValue, cookieMaxage, encodeString); &#125; /** * 删除Cookie带cookie域名 */ public static void deleteCookie(HttpServletRequest request, HttpServletResponse response, String cookieName) &#123; doSetCookie(request, response, cookieName, "", -1, false); &#125; /** * 设置Cookie的值，并使其在指定时间内生效 * * @param cookieMaxage cookie生效的最大秒数 */ private static final void doSetCookie(HttpServletRequest request, HttpServletResponse response, String cookieName, String cookieValue, int cookieMaxage, boolean isEncode) &#123; try &#123; if (cookieValue == null) &#123; cookieValue = ""; &#125; else if (isEncode) &#123; cookieValue = URLEncoder.encode(cookieValue, "utf-8"); &#125; Cookie cookie = new Cookie(cookieName, cookieValue); if (cookieMaxage &gt; 0) cookie.setMaxAge(cookieMaxage); if (null != request) &#123;// 设置域名的cookie String domainName = getDomainName(request);// System.out.println(domainName); if (!"localhost".equals(domainName)) &#123; cookie.setDomain(domainName); &#125; &#125; cookie.setPath("/"); response.addCookie(cookie); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 设置Cookie的值，并使其在指定时间内生效 * * @param cookieMaxage cookie生效的最大秒数 */ private static final void doSetCookie(HttpServletRequest request, HttpServletResponse response, String cookieName, String cookieValue, int cookieMaxage, String encodeString) &#123; try &#123; if (cookieValue == null) &#123; cookieValue = ""; &#125; else &#123; cookieValue = URLEncoder.encode(cookieValue, encodeString); &#125; Cookie cookie = new Cookie(cookieName, cookieValue); if (cookieMaxage &gt; 0) cookie.setMaxAge(cookieMaxage); if (null != request) &#123;// 设置域名的cookie String domainName = getDomainName(request);// System.out.println(domainName); if (!"localhost".equals(domainName)) &#123; cookie.setDomain(domainName); &#125; &#125; cookie.setPath("/"); response.addCookie(cookie); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 得到cookie的域名 */ private static final String getDomainName(HttpServletRequest request) &#123; String domainName = null; String serverName = request.getRequestURL().toString(); if (serverName == null || serverName.equals("")) &#123; domainName = ""; &#125; else &#123; serverName = serverName.toLowerCase(); serverName = serverName.substring(7); final int end = serverName.indexOf("/"); serverName = serverName.substring(0, end); final String[] domains = serverName.split("\\."); int len = domains.length; if (len &gt; 3) &#123; // www.xxx.com.cn domainName = "." + domains[len - 3] + "." + domains[len - 2] + "." + domains[len - 1]; &#125; else if (len &lt;= 3 &amp;&amp; len &gt; 1) &#123; // xxx.com or xxx.cn domainName = "." + domains[len - 2] + "." + domains[len - 1]; &#125; else &#123; domainName = serverName; &#125; &#125; if (domainName != null &amp;&amp; domainName.indexOf(":") &gt; 0) &#123; String[] ary = domainName.split("\\:"); domainName = ary[0]; &#125; return domainName; &#125;&#125; 前端获取Cookie 的方法12345678910111213141516171819202122232425262728293031323334// 想要获取的cook键值 var cookie_name = "userInfo"; // 调用 var cookie_value = getCookie(cookie_name); //对获取的字符串进行截取字符串数组 var split = cookie_value.split(":"); // 遍历数组 for (var i = 0; i &lt; split.length; i++) &#123; alert(split[i]); &#125; function getCookie(cookie_name) &#123; var allcookies = document.cookie; //索引长度，开始索引的位置 var cookie_pos = allcookies.indexOf(cookie_name); // 如果找到了索引，就代表cookie存在,否则不存在 if (cookie_pos != -1) &#123; // 把cookie_pos放在值的开始，只要给值加1即可 //计算取cookie值得开始索引，加的1为“=” cookie_pos = cookie_pos + cookie_name.length + 1; //计算取cookie值得结束索引 var cookie_end = allcookies.indexOf(";", cookie_pos); if (cookie_end == -1) &#123; cookie_end = allcookies.length; &#125; //得到想要的cookie的值 var value = unescape(allcookies.substring(cookie_pos, cookie_end)); &#125; return value; &#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>CookieUtils</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDBC事务]]></title>
    <url>%2F2019%2F04%2F17%2FJDBC%E4%BA%8B%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[什么是事务概念： 事务一般指的数据库事务，是指作为一个程序执行单元执行的一系列操作，要么完全执行，要么完全不执行 事务的特性 原子性：一个事务是一个不可分割的工作单位 一致性：事务必须是使数据库 一个一致性状态转换到另一个一致性 隔离性： 一个事务的执行不能被其他事务影响 持久性： 一个事务一旦提交他对数据的的数据改变应该是永久的 Mysql 事务处理 mysql 只有Innodb 数据库引擎的数据库支持事务 show engines 查看服务器的引擎 default -storage -engine=Innodb —my.ini 修改默认引擎 Mysql 默认自动提交模式 事务处理语句 - start transaction ：开始事务 - commint: 提交事务 - rollback : 回滚 事务并发问题 在事务的并发情况,不考虑事务的隔离性 回发生 脏读 — 最严重不可发生的:指一个事务读取了另外一个事务 未提交的数据 不可重复读 ：在一个事务内多次读取表中的数据，多次读取的结果不同 幻读 ： 隔离级别 数据库规定了4中隔离级别 read uncommitted读未提交，一个事务读到另一个事务没有提交的数据。 存在：3个问题（脏读、不可重复读、虚读）。 解决：0个问题 read committed 读已提交，一个事务读到另一个事务已经提交的数据。 存在：2个问题（不可重复读、虚读）。 解决：1个问题（脏读） repeatable read:可重复读，在一个事务中读到的数据始终保持一致，无论另一个事务是否提交。 存在：1个问题（虚读）。 解决：2个问题（脏读、不可重复读） serializable串行化，同时只能执行一个事务，相当于事务中的单线程。 存在：0个问题。 解决：3个问题（脏读、不可重复读、虚读） 查看Mysql 的隔离级别mysql：8.0以下：select @@tx_isolation; mysql 8.0 以上 select @@transaction_isolation; 设置当前会话设置隔离级别set session transaction isolation level XXXX(对应隔离级别); 隔离离别的安全性和性能差距 安全性: serializable&gt;repeatable read&gt; read committed &gt; read uncommitted 性能： serializable &lt; repeatable read&lt; read committed&lt; read uncommitted Spring 事务处理 事务的传播行为 事务管理器]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在spring中Resouc注解无法使用]]></title>
    <url>%2F2019%2F04%2F16%2F%E5%9C%A8spring%E4%B8%ADResouc%E6%B3%A8%E8%A7%A3%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[在Spring项目中引入@Resource注解的时候，有红色下划线错误，而且输入注解的时候不能出现自动代码补全。加入javax.annotation包后，出现警告 出现原因缺少jar包 用Maven 导入jar包 123456&lt;dependency&gt; &lt;groupId&gt;javax.annotation&lt;/groupId&gt; &lt;artifactId&gt;jsr250-api&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt;&lt;/dependency&gt;]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>踩过的坑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[“mybatis的概述”]]></title>
    <url>%2F2019%2F04%2F07%2Fmybatis%E7%9A%84%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[什么是MyBatis？MyBatis是一个第一类持久性框架，支持自定义SQL，存储过程和高级映射。MyBatis几乎消除了所有JDBC代码和手动设置参数以及检索结果。MyBatis可以使用简单的XML或Annotations来配置和映射基元，Map接口和Java POJO（Plain Old Java Objects）到数据库记录。 ORM :对象关系映射Object Relation Mapping ###传统JDBC 程序的设计缺陷１．大量的配置信息的硬代码２．大量的无关业务处理３．编码扩展优化极其不便 Mybatis 的基本概述 避免传统的jdbc 硬编码 XML配置或者注解 POJP对像和数据库记录直接映射 完善的文档支持Mybatis 的优势 简单易学，快速上手，学习成本低 数据库交互信息配置化 动态SQL语句 Mybatis 使用场景 更加关注SQL优化的项目 需求更换平凡的项目 Mybatis 的开发环境的搭建获取Mybatis 的下载 Mybatis的官方网站 : http://www.mybatis.org/mybatis-3/zh/index.htm Mubatis 的下载方式： １.github代码库下载：https://github.com/mybatis/mybatis-3/tree/master/src/site ２.Maven 方式引入 Mybatis 基本使用案例 0．导入所需jar包12345678910111213141516171819202122232425262728&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.imooc.Mybatis&lt;/groupId&gt; &lt;artifactId&gt;Mybatis-Demo1&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.44&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; １．创建数据库和表1234567id INT AUTO_INCREMENT PRIMARY KEY COMMENT '用户编号', username VARCHAR(50) COMMENT '用户名', userpass VARCHAR(50) COMMENT '用户密码',nikename VARCHAR(20) COMMENT '昵称');SELECT * FROM users;INSERT INTO users VALUES(4,'wh','wh','wh' ); 2.创建数据库对应的实体类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.imooc.Demo;public class Users &#123; private int id; private String username; private String userpass; private String nikename; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getUserpass() &#123; return userpass; &#125; public void setUserpass(String userpass) &#123; this.userpass = userpass; &#125; public String getNikename() &#123; return nikename; &#125; public void setNikename(String nikename) &#123; this.nikename = nikename; &#125; @Override public String toString() &#123; return "Users&#123;" + "id=" + id + ", username='" + username + '\'' + ", userpass='" + userpass + '\'' + ", nikename='" + nikename + '\'' + '&#125;'; &#125;&#125; 3.创建mybatyis的配置文件mybatis.XML 12345678910111213141516171819202122232425262728293031323334 &lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!--1.environments主要用于进行数据源的配置，可以配置多个数据源，听过default属性来指定当前项目运行过程中使用的是哪个数据源2.environment用于配置一个具体的独立的数据源，id属性用于给当前数据源定义一个名称，方便我们项目指定3.transactionManager用于配置事务管理，默认情况下使用的是JDBC事务管理4.datasource具体数据源的连接信息，type属性用于指定是否使用连接，type=POOLED是使用连接池5.mappers主要用于配置外部的映射配置文件，在主配置文件中需要引入加载映射配置文件mapper主要配置引入某一个具体的映射文件（resource路径方式引入）6.resource下建立mapper文件夹，建立xxxxMapper.xml映射配置文件mapper定义一个映射配置文件根节点namespace用于配置当前的命名空间，主要用于进行session级别的缓存管理，默认使用当前操作的实体类的全路径 --&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC"/&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/test?&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF8"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="root"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt;&lt;!--引入外部的ｍapper 配置文件--&gt; &lt;mappers&gt; &lt;mapper resource="mapper/usersMapper.XML"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 4.创建mapper配置文件usersMapper.XML 1234567891011&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!--namespace 这个一般是实体类的绝对路径--&gt;&lt;mapper namespace="com.imooc.Demo.Users"&gt; &lt;!--resultType 返回值类型 就是实体类--&gt; &lt;select id="DemoUsers" resultType="com.imooc.Demo.Users"&gt; select * from users &lt;/select&gt;&lt;/mapper&gt; 5.进行测试 123456789101112131415161718192021222324252627import com.imooc.Demo.Users;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.IOException;import java.io.InputStream;import java.util.List;public class Test &#123; @org.junit.Test public void test() throws IOException &#123;// 初始化mybatis 的配置文件 String resources = "Mybatis_Demo1.XML"; InputStream resources1 = Resources.getResourceAsStream(resources); SqlSessionFactory Factory = new SqlSessionFactoryBuilder().build(resources1);// 建立数据库之间的会话 SqlSession sqlSession = Factory.openSession(); List&lt;Users&gt; demoUsers = sqlSession.selectList("DemoUsers"); for (Users users : demoUsers ) &#123; System.out.println(users); &#125; &#125;&#125; 执行结果1234Users&#123;id=1, username='admin', userpass='admin', nikename='gyc'&#125;Users&#123;id=2, username='gyc', userpass='gyc', nikename='gyc'&#125;Users&#123;id=3, username='zero', userpass='zero', nikename='zero'&#125;Users&#123;id=4, username='wh', userpass='wh', nikename='wh'&#125;]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣题-解决整数翻转]]></title>
    <url>%2F2019%2F04%2F06%2F%E5%8A%9B%E6%89%A3%E9%A2%98-%E8%A7%A3%E5%86%B3%E6%95%B4%E6%95%B0%E7%BF%BB%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[题目描述 给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 解题步骤 英文int 的类型大小刚好是符合该32位的范围 所以不用考虑溢出问题 直接捕获异常处理就行 判断是否为零 和是否小于零 如果为零直接返回 当传入的值小于零时 先将其变为正数 再将该int 值转化为String 类型 创建stringbuilid 对象传入该string值 利用stringbulid 对象翻转的方法 生成新的string对象 将生成的新的对象转为interger 对象 如果传入值时为负数 就将该对象*-1 变为负数返回 如果传入的值为正数 直接返回 代码实现123456789101112131415161718192021public static int reverse(int x) &#123; try &#123; if (x == 0) &#123; return 0; &#125; if (x &lt; 0) &#123; x = -x; return -Integer.parseInt(new StringBuilder(String.valueOf(x)).reverse().toString()); &#125; if (x &gt; 0) &#123; return Integer.parseInt(new StringBuilder(String.valueOf(x)).reverse().toString()); &#125; &#125; catch (Exception e) &#123; return 0; &#125; return 0; &#125; 运行结果]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>力扣</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE 的基本数据结构]]></title>
    <url>%2F2019%2F03%2F19%2FjavaSE-%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[数据结构 编程的本质是对数据（信息以数据的形式存在）,实际编程中不得不处理大量的数据，因此实际动手编程之前必须分析这些数据，处理数据之间的关系 现实的数据元素之间之间有着纷繁复杂的逻辑关系，需要采用的是物理结构来存储这些数据并以这些数据基础对数据进行相应的操作。同时还要在分析这些数据在空间时间的开销优势。 对于专门研究应用程序中的数据之间逻辑关系，存储方式及其操作就是数据结构。 逻辑结构 数据结构元素之间存在关联关系被称为数据结构的逻辑结构，应用程序的数据结构大致有四种基本逻辑结构： 集合：数据集元素之间只存在同数据一个集合的关系 线性关系 数据元素之间存在一个对应一个的关系 树状结构：数据元素之间存在一个对多个的关系 图状结构或者网状结构：数据元素之间存在多个对多个的关系![数据结构](http://www.fxyh97.com/usr/uploads/2018/10/3052981165.png) 排序算法 排序算法的目的：通常来说排序的目的就是快速查找 衡量排序算法的优劣 时间复杂度：分析关键字比较次数和记录的移动次数 空间复杂度：分析排序算法中需要多少辅助内存 稳定性 若两个记录A和B的关键字相等，但是排序后A，B的先后次序保存不变，则这算法是稳定的 常用的排序算法 选择排序：直接选择排序，堆排序 交换排序：冒泡排序，快速排序 插入排序：直接插入排序 ，折半排序 ，shell排序 并归排序： 桐式排序 基数排序 java中排序工具类：Arrays.sort(); 基本算法实现 选择排序：要排序的一组数据中，选出最小的一个数与第一个数的位置进行比较交换，然后再剩下的数当中再找最小的与第二的位置进行交换位置，如此循环倒数第二个和最后一个进行比较 1234567891011121314 public static void selectSort(int[] arr)&#123; for(int i = 0; i &lt; arr.length; i++)&#123; int k = i;//待确定的位置 for(int j = arr.length-1; j &gt; i; j--)&#123; if(arr[j] &lt; arr[k])&#123; k = j;//记录第i个最小值位置 &#125; &#125; //将第i个位置的元素与此轮找到最小的值交换 int temp = arr[i]; arr[i] = arr[k]; arr[k] = temp; &#125;&#125; - 冒泡排序:比较相邻两个元素的大小，如果后一个元素比前一个元素小，则交换两个元素的位置。一轮之后最大的元素会沉到底部。小的元素会逐渐往上浮，故称为冒泡排序 12345678910111213public static void bubbleSort(int[] arr)&#123; int temp = 0; //起始比较位置 int size = arr.length; //数组的元素个数 for(int i = 0; j &lt; size-1; i++)&#123;//外层控制轮次 for(int j = 0; j &lt; size-1-j; j++)&#123;//内层进行比较 if(arr[j] &gt; a[j+1])&#123; temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; &#125; &#125; &#125;&#125; 插入排序：每步将一个待排序的记录，按其顺序码大小插入到前面已经排序的字序列的合适位置(从后向前找到合适位置后),知道全部插入排序完为止 12345678910111213public static void insertSort(int[] arr)&#123; int size = arr.length; int temp = 0; int j = 0; for(int i = 0; i &lt; size; i++)&#123; temp = arr[i]; //假如temp比前面的值小，则将前面的值后移 for(j = i; j &gt; 0 &amp;&amp; temp &lt; arr[j-1]; j--)&#123; arr[j] = arr[j-1]; &#125; arr[j] = temp; &#125;&#125; 转至 JavaSE-数据结构和排序算法]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-工厂模式-工厂方法模式]]></title>
    <url>%2F2019%2F03%2F02%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[定义与类型 定义：定义一个创建对象的接口但让实现这个接口的类来决定实例化哪个类,工厂方法让类的实例化推迟到子类中进行 类型：创建型 使用场景 创建对象需要大量重复代码 客户端(应用层)不依赖于产品类实例如何被创建实现等细节 一个类通过其子类指定创建哪个对象 优点 用户只需要关心所需产品对应的工厂,不用关心创建细节 加入新产品符合开闭原则,提高可扩展性 缺点 类个数过多增加复杂度 增加了系统抽象性和理解难度 用代码实现理解 创建视频接口 12345678910111213141516/** * @program: designmode_ pattern * @description: 简单工厂中的视频接口 * @author: Gyc * @create: 2019-04-29 10:41 **/public abstract class Video &#123; /** * @Author Gyc * @Description 所有产品通用方法 录制视频 * @Date 10:43 2019-04-29 * @Param [] * @return void **/ public abstract void produce();&#125; 创建实现类 1234567891011121314151617public class JavaFaction extends VideoFaction &#123; public Video getVido() &#123; return new JavaVideo(); &#125;&#125;public class HtmlVide extends Video &#123; public void produce() &#123; System.out.println("创建前端视频"); &#125;&#125;public class PythonFaction extends VideoFaction &#123; public Video getVido() &#123; return new PythonVideo(); &#125;&#125; 创建工厂接口让子类工厂实现(工厂方法让类的实例化推迟到子类中进行) 123456789/** * @program: designmode_ pattern * @description: 简单工厂中的视频工厂接口 * @author: Gyc * @create: 2019-04-29 10:40 **/public abstract class VideoFaction &#123; public abstract Video getVido();&#125; 子类实现视频工厂接口 123456789101112131415161718192021222324252627282930313233343536373839/** * @program: design * @description: java工厂 * @author: Gyc * @create: 2019-05-05 19:30 **/public class JavaFaction extends VideoFaction &#123; public Video getVido() &#123; return new JavaVideo(); &#125;&#125;/** * @program: design * @description: * @author: Gyc * @create: 2019-05-05 19:44 **/public class HtmlVide extends Video &#123; public void produce() &#123; System.out.println("创建前端视频"); &#125;&#125;/** * @program: design * @description: Python 工厂 * @author: Gyc * @create: 2019-05-05 19:31 **/public class PythonFaction extends VideoFaction &#123; public Video getVido() &#123; return new PythonVideo(); &#125;&#125; 测试 UML 类图 产品族 和产品等级结构概念 产品等级结构：产品等级结构即产品的继承结构 产品族: 产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品 例子 java视频 python 视频 它们是同一个视频等级 java笔记 python 笔记 它们是同一个笔记等级 java视频和java笔记是由java工厂创建 python视频个python笔记是由 python工厂创建 java视频+java笔记 就是一个java产品族 python视频+python笔记 就是一个python产品族 用类图表示理解 用生活中实物表示理解 抽象工厂和工厂方法 工厂方法常生产的同一等级结构中的固定产品 抽象工厂常生产不同产品族的全部产品]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>工厂方法</tag>
        <tag>工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-工厂模式-简单工厂模式]]></title>
    <url>%2F2019%2F01%2F09%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[简单工厂模式介绍###模型原理 组成 关系 作用 抽象产品 具体产品父类 描述产品的功能公共接口 具体产品 抽象产品的子类：由工厂创造 生产具体产品 工厂 被外界调用：创建抽象产品子类 根据传参产生具体实例 UML 类图 Video :抽象产品父类 VideoFaction:工厂 PythonVideo JavaVideo : 具体实现类 由工厂创建 使用步骤 创建抽象产品父类 创建具体产品类 创建工厂类 外部调用 Java代码实现实例 创建抽象产品类 12345678910public abstract class Video &#123; /** * @Author Gyc * @Description 所有产品通用方法 录制视频 * @Date 10:43 2019-04-29 * @Param [] * @return void **/ public abstract void produce();&#125; 创建子类实现 1234567891011121314public class PythonVideo extends Video &#123; @Override public void produce() &#123; System.out.println("录制Python视频"); &#125;&#125;public class JavaVideo extends Video &#123; @Override public void produce() &#123; System.out.println("录制java视频"); &#125;&#125; 3.创建工厂实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class VideoFaction &#123; /** * @Author Gyc * @Description //TODO 不使用简单反射创建实例 * @Date 14:24 2019-04-29 * @Param [type] * @return com.zerolg.designmode.operation_factory.Video **/ public Video getVido(String type) &#123; if (type.equalsIgnoreCase("java")) &#123; return new JavaVideo(); &#125; else if (type.equalsIgnoreCase("python"))&#123; return new PythonVideo(); &#125; else &#123; return null; &#125; &#125; /** * @return com.zerolg.designmode.operation_factory.Video * @Author Gyc * @Description //TODO 用反射创建 * @Date 11:12 2019-04-29 * @Param [video] **/ public static Video getVido(Class v) &#123; Video video = null; try &#123; video = (Video) Class.forName(v.getName()).newInstance(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; return video; &#125;&#125; 外界传参数调用 12345678910111213141516171819public class Test &#123; public static void main(String[] args) &#123; /*直接使用工厂创建实例*/ VideoFaction videoFaction = new VideoFaction(); Video video2 = videoFaction.getVido("java"); if (video == null) &#123; return; &#125; video2.produce(); /* 使用反射创建实例*/ VideoFaction videoFaction = new VideoFaction(); Video vido = videoFaction.getVido(JavaVideo.class); vido.produce(); &#125;&#125; 优缺点分析优点: 将创建的实例的工作与实例工作分开，使用者不必关心类对象的如何创建，实现了解耦 将实例初始化放在工厂中，让代码更容易维护，符合面向对象的原则，面向接口编程 缺点: 工厂中集合了所以的实例创造，一旦工厂出现问题，将影响整个系统 简单工厂模式由于使用了静态工厂方法，静态方法不能被继承和重写，会造成工厂角色无法形成基于继承的等级结构 当不使用反射创建实例时,违背“开放 - 关闭原则”，一旦添加新产品就不得不修改工厂类的逻辑，这样就会造成工厂逻辑过于复杂 应用场景 当对如何创建对象逻辑不关心，只关心产生的实例 当工厂类负责创建的对象比较少时(创建对象过多会造成的工厂逻辑过于复杂)]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>工厂模式</tag>
        <tag>简单工厂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[deepin安装MySQL没有弹出设置root密码怎么进行修改]]></title>
    <url>%2F2019%2F01%2F09%2Fdeepin%E5%AE%89%E8%A3%85MySQL%E6%B2%A1%E6%9C%89%E5%BC%B9%E5%87%BA%E8%AE%BE%E7%BD%AEroot%E5%AF%86%E7%A0%81%E6%80%8E%E4%B9%88%E8%BF%9B%E8%A1%8C%E4%BF%AE%E6%94%B9%2F</url>
    <content type="text"><![CDATA[1. 首先使用apt命令安装mysql（默认安装的最新5.7）1sudo apt-get update 1sudo apt-get install mysql-server mysql-client 2.修改my.cnf,不过我修改之后报错，最后修改的是 `1/etc/mysql/mysql.conf.d/mysqld.cnf 3.最文件最底下插入一条：1skip-grant-tables 4.然后重启mysql服务1sudo service mysql restart 5.shell直接使用root进去1mysql -uroot -p 6.修改密码1ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '要设置的密码'; 7.退出，重新启动mysql 服务12exit 12sudo service mysql restart 8.用密码登入1mysql -uroot -p 然后输入你修改的密码，这时密码是不会显示的，直接回车就行，出现这个就是登入成功了！]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat闪退解决]]></title>
    <url>%2F2019%2F01%2F09%2FTomcat%E9%97%AA%E9%80%80%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[1.寻找原因要解决原因 肯定要先找到原因啦,进入命令行提示符程序中找到tocmcat程序bin目录下的startup.bat windos+R 输入cmd 然后确定进入命令提示符程序 1CD D:Tocamt\apache-tomcat-7.0.88\bin \startup.bat 2.(这个Tomcat 路径 根据个人情况下的Tomcat路径) 运行 查看错误情况 1.如果提示缺少JAVA_HOME或者JRE_HOME则是 java基本环境变量出错 2.如果缺少CATALINA_HOME(如图所示) 则需要配置CATALINA_HOME变量 2.解决方案1 .配置JAVA基本环境这个网上有一大推我就不写了 ,网上搜搜就来了 配置好了后 重新启动Tomcat 程序就好了2.配置 CATALINA_HOME 变量错误提示缺少 catalin_home 环境变量 计算机-属性-高级系统设置-环境变量 -新建环境变量 - 变量名字 CATALINA_HOME 变量值 Tomcat 解压位置 PATH 添加刚才的环境变量 1%CATALINA_HOME%\bin (这个Tomcat 路径 根据个人情况下的Tomcat路径) 运行 3.重新启动Tomcat 然后去http://localhost:8080, 看是否启动正常4.关闭Tomcat 1/shutdown.bat]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux 环境下安装jdk和Tomcat]]></title>
    <url>%2F2019%2F01%2F09%2Flinux%E4%B8%8B%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AEjdk%E3%80%81tomcat%E7%9A%84%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[安装ＪＤＫ 先查看下有没有安装openjdk 1dpkg -l | grep openjdk 2.安装的话，使用下面命令卸载 1sudo apt remove openjdk* 3.jdk下载戳我进入下载 进入官网后点 accept 然后找对应的系统版本的jdk下载即可。 ４.然后将下载下来的压缩包解压到一个你找的到路径（我这里放到/usr/java下，并且重命名了） 12sudo tar -xzf jdk-8u181-linux-x64.tar.gz -C /usr/java/sudo mv /usr/java/jdk1.8.0_181/ /usr/java/jdk 5.配置环境变量 linux中环境变量可以在以下几个文件中配置，不过不同的文件实现不同： 1234- `/etc/envirnment`:配置的是整个系统的环境变量- `/etc/profile`:配置所有用户的环境变量- `~/.profile`:配置*当前*用户的环境变量- `~/.bashrc`:每次加载bash时加载的环境配置 所以我们使用第二个就好了 1 不过需要注意的是，在/etc/environment 中不能包含命令，即直接通过VAR=”…”的方式设置，不使用 export。而在/etc/profile中可以使用export来添加环境变量。 然后直接在终端输入下面的命令就可以了。 1234567１．sudo echo &apos;####JDK环境变量配置####２．export JAVA_HOME=/usr/java/jdk３．export JRE_HOME=$JAVA_HOME/jre４．export CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/lib５．export PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$PATH&apos; &gt;&gt; /etc/profile 然后，source /etc/profile生效配置。 然后在终端输入java -version,如果输出是下面则成功了： 1231.java version &quot;1.8.0_181&quot;2.Java(TM) SE Runtime Environment (build 1.8.0_181-b13)3.Java HotSpot(TM) 64-Bit Server VM (build 25.181-b13, mixed mode) 安装tomcat由于我们已经配置好了jdk，所以可以直接来下载tomcat tomcat下载：戳我下载tomcat 解压文件到一个你能找的到目录下（这里解压到/usr/tomcat）： 12341.sudo mkdir ~/tomcat2.sudo tar -xzvf apache-tomcat-9.0.12.tar.gz -C ~/tomcat3.sudo mv ~/tomcat/apache-tomcat-9.0.12/* ~/tomcat4.sudo rm -r ~/tomcat/apache-tomcat-9.0.12 4.启动tomcat服务，进入解压目录下的/bin目录，运行./startup.sh,如果显示如下命令则，正常安装成功。 12345671.Using CATALINA_BASE: /home/weison/tomcat2.Using CATALINA_HOME: /home/weison/tomcat3.Using CATALINA_TMPDIR: /home/weison/tomcat/temp4.Using JRE_HOME: /usr/java/jdk/jre5.Using CLASSPATH: /home/weison/tomcat/bin/bootstrap.jar:/home/weison/tomcat/bin/tomcat- juli.jar6.Tomcat started.]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算java中数组中没有相同元素的个数]]></title>
    <url>%2F2018%2F03%2F14%2F%E8%AE%A1%E7%AE%97java%E4%B8%AD%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B2%A1%E6%9C%89%E7%9B%B8%E5%90%8C%E5%85%83%E7%B4%A0%E7%9A%84%E4%B8%AA%E6%95%B0%2F</url>
    <content type="text"><![CDATA[问题描述 一个数组找出该数组中只出现一次的元素个数 解决思路 先遍历数组（控制遍历次数） 再遍历数组 （ ） 用两次遍历的元素进行比较 判断比较是的是否是同一个元素 是同一个元素直接跳出循环 然后判断元素是否相等如果相等的话则用一个计数器(记录数组中出现相同元素的个数 ) 在二次循环外第一次循环中判断相同元素个数 如果为零就表示该元素只出现一次 用一个另一个计数器记录出来 总而言之就是循环的用自己和数组中的所有其他元素进行比较(效率较低) 代码实现1234567891011121314151617181920212223 public static int Demo2(String[] s) &#123;// 记录元素出现1次的个数 int num = 0; for (int i = 0; i &lt; s.length; i++) &#123;// 记录数组中出现相同元素的个数 int sum = 0; for (int j = 0; j &lt; s.length; j++) &#123;// 判断是否是否是同一个元素 不需要自己比较 if (i == j) &#123; continue; &#125; else if (s[i] == s[j]) &#123; sum++; &#125; &#125;// 如果出现相同元素的个数为零就表示这个元素在整个数组中只出现了一次 if (sum == 0) &#123; num++; &#125; &#125; return num; &#125; 这是我想到最简单的方法了,所以最暴力的！希望如果有更优化的解法欢迎留言教导我]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
</search>
